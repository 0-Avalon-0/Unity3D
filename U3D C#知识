7.17：

日志输入和输出：
print();//只能在继承Monobehaviour中才能使用
Debug.Log();//任何情况都能使用
Debug.LogWarning();//符号不一样，为警示符
Debug.LogError();//报出错误

vs 注释快捷键 ctrl+k -> ctrl+c

c#枚举声明（在该类外面声明）：
enum Type{
  A,
  B,
  C
}//即为定义好的一个类型
使用方式：Type temp = Type.A;

创建vector3(位置)实例：new vector3(1,1,1)

类的新建实例(new)

Update中写Input.GetAxis("Horizontal")可以获得用户水平输入

定义命名空间和内部类：
namespace ns{
  class a{
  }
}

脚本中参数初始值以inspector中给的值为准，不是脚本中初始化的值。
GetComponent<BoxCollider>();

Colliders [] t = GetComponents<Collider>();//可能有同名组件，所以用数组接收
foreach(Collider c in t){

}

组件的禁用和激活：
首先GetComponent获得
修改Component.enabled(就是修改组件前面的勾选框)

组件被禁用，其中的方法依然可以调用





7.19：

start函数里通常用来初始化脚本

获取键盘输入：
Input.Getkey();//按下某键后，如果一直按着则持续返回true
Input.GetKeyDown();//按下的一瞬间返回true
Input.GetKeyUp();//抬起的一瞬间返回true
参数均为KeyCode
KeyCode是一个枚举类型，使用时直接如KeyCode.A即可

获取鼠标输入：
Input.GetMouseButton();//按下某键后，如果一直按着则持续返回true
Input.GetMouseButtonDown();//按下的一瞬间返回true
Input.GetMouseButtonUp();//抬起的一瞬间返回true
参数：鼠标按键索引值：0->左键，1->右键，2->中键



理解：
游戏物体本身是一个大的对象，管理众多组件（小对象）
这些对象都有自身的字段，属性和方法
组件实质上是类（看到脚本即可理解），当游戏运行后，引擎会自动实例化



使用Transform变换组件移动物体：
方法：gameObject.GetComponent<T>() 获取相应组件
Transform（获取的transform组件）.Translate(Vector3,Space) 移动物体位置（自身坐标系或者世界坐标系）

Vector3向量本质是一个结构体，向量可以表示一个方向，或者一个位置。
Vector3.forward（速度过快可以乘小数，如0.1f）

Space本质是一个枚举
Space.Self:物体自身坐标系
Space.World:物体所在世界坐标系


！！：正常开发不使用变换组件来移动物体：这种移动会穿透其他物体，且不受重力影响


刚体RigidBody:
刚体组件属性：
Mass质量，单位kg
Drag阻力，0表示无阻力，值很大时物体会停止运动
Angular Drag受到扭曲力时的空气阻力，0表示无阻力，值很大时物体会停止运动
(e.g.:两物体碰撞后旋转所受阻力，角阻力很大不会旋转)
Use Gravity

使用刚体移动物体：
方法：Rigidbody.MovePosition(Vector3):使用刚体移动位置
使用刚体移动时，物体根据世界坐标系移动
同时会触发物理相关的事件。

参数要满足:使用 当前位置+方向 的方式，否则（样例中出现的问题：穿过plane下落）
当前位置为一个属性，Transform.Position来获取




7.20：
碰撞体：
两物体碰撞实质上是碰撞体之间的碰撞。
没有碰撞体无法碰撞。

创建刚体必须创建碰撞体，否则无意义。

刚体 + 碰撞体 -> 碰撞体：碰撞，但是撞不动。（没有刚体，无法判断物理受力）
刚体 -> 碰撞体：源物体会直接落下。（没有碰撞体，无法判断碰撞事件，但是有刚体来受力）
刚体 + 碰撞体 -> 纯物体：直接穿过。（没有碰撞体）
都有：正常。

Mesh Collider:
适用于复杂物体。
使用时选择对应的Mesh属性。


刚体常用方法：
AddForce:给刚体添加一个力，按 世界坐标系 移动。

Rigidbody.AddForce(Vector3,ForceMode):其中ForceMode是枚举类型

ForceMode枚举：
Acceleration：加速度。
Force：通常用于设置真实的物理，使用频率最高。
Impulse：通常用于瞬间发生的力。
VelocityChange：速度变化。

AddRelativeForce:添加一个力，按 自身坐标系 移动。
Rigidbody.AddRelativeForce(Vector3,ForceMode):其中ForceMode是枚举类型


FixedUpdate方法：
固定更新方法。
所有和物理相关的操作都要写在FixedUpdate中。
固定更新方法一次0.02秒，一秒50次。
Edit -> Project Settings -> Time 可以修改Fixed Timestep修改时间间隔。

Update()方法是每帧执行一次。
画面每渲染完一次就是一帧，每帧的时间不固定（和场景有关系）。

在Update（）方法中执行物理操作，会出现卡顿。









