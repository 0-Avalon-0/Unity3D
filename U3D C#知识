7.17：

日志输入和输出：
print();//只能在继承Monobehaviour中才能使用
Debug.Log();//任何情况都能使用
Debug.LogWarning();//符号不一样，为警示符
Debug.LogError();//报出错误

vs 注释快捷键 ctrl+k -> ctrl+c

c#枚举声明（在该类外面声明）：
enum Type{
  A,
  B,
  C
}//即为定义好的一个类型
使用方式：Type temp = Type.A;

创建vector3(位置)实例：new vector3(1,1,1)

类的新建实例(new)

Update中写Input.GetAxis("Horizontal")可以获得用户水平输入

定义命名空间和内部类：
namespace ns{
  class a{
  }
}

脚本中参数初始值以inspector中给的值为准，不是脚本中初始化的值。
GetComponent<BoxCollider>();

Colliders [] t = GetComponents<Collider>();//可能有同名组件，所以用数组接收
foreach(Collider c in t){

}

组件的禁用和激活：
首先GetComponent获得
修改Component.enabled(就是修改组件前面的勾选框)

组件被禁用，其中的方法依然可以调用





7.19：

start函数里通常用来初始化脚本

获取键盘输入：
Input.Getkey();//按下某键后，如果一直按着则持续返回true
Input.GetKeyDown();//按下的一瞬间返回true
Input.GetKeyUp();//抬起的一瞬间返回true
参数均为KeyCode
KeyCode是一个枚举类型，使用时直接如KeyCode.A即可

获取鼠标输入：
Input.GetMouseButton();//按下某键后，如果一直按着则持续返回true
Input.GetMouseButtonDown();//按下的一瞬间返回true
Input.GetMouseButtonUp();//抬起的一瞬间返回true
参数：鼠标按键索引值：0->左键，1->右键，2->中键



理解：
游戏物体本身是一个大的对象，管理众多组件（小对象）
这些对象都有自身的字段，属性和方法
组件实质上是类（看到脚本即可理解），当游戏运行后，引擎会自动实例化



使用Transform变换组件移动物体：
方法：gameObject.GetComponent<T>() 获取相应组件
Transform（获取的transform组件）.Translate(Vector3,Space) 移动物体位置（自身坐标系或者世界坐标系）

Vector3向量本质是一个结构体，向量可以表示一个方向，或者一个位置。
Vector3.forward（速度过快可以乘小数，如0.1f）

Space本质是一个枚举
Space.Self:物体自身坐标系
Space.World:物体所在世界坐标系


！！：正常开发不使用变换组件来移动物体：这种移动会穿透其他物体，且不受重力影响


刚体RigidBody:
刚体组件属性：
Mass质量，单位kg
Drag阻力，0表示无阻力，值很大时物体会停止运动
Angular Drag受到扭曲力时的空气阻力，0表示无阻力，值很大时物体会停止运动
(e.g.:两物体碰撞后旋转所受阻力，角阻力很大不会旋转)
Use Gravity

使用刚体移动物体：
方法：Rigidbody.MovePosition(Vector3):使用刚体移动位置
使用刚体移动时，物体根据世界坐标系移动
同时会触发物理相关的事件。

参数要满足:使用 当前位置+方向 的方式，否则（样例中出现的问题：穿过plane下落）
当前位置为一个属性，Transform.Position来获取




7.20：
碰撞体：
两物体碰撞实质上是碰撞体之间的碰撞。
没有碰撞体无法碰撞。

创建刚体必须创建碰撞体，否则无意义。

刚体 + 碰撞体 -> 碰撞体：碰撞，但是撞不动。（没有刚体，无法判断物理受力）
刚体 -> 碰撞体：源物体会直接落下。（没有碰撞体，无法判断碰撞事件，但是有刚体来受力）
刚体 + 碰撞体 -> 纯物体：直接穿过。（没有碰撞体）
碰撞体 -> 刚体+碰撞体：直接穿过。
都有：正常。

Mesh Collider:
适用于复杂物体。
使用时选择对应的Mesh属性。


刚体常用方法：
AddForce:给刚体添加一个力，按 世界坐标系 移动。

Rigidbody.AddForce(Vector3,ForceMode):其中ForceMode是枚举类型

ForceMode枚举：
Acceleration：加速度。
Force：通常用于设置真实的物理，使用频率最高。
Impulse：通常用于瞬间发生的力。
VelocityChange：速度变化。

AddRelativeForce:添加一个力，按 自身坐标系 移动。
Rigidbody.AddRelativeForce(Vector3,ForceMode):其中ForceMode是枚举类型


FixedUpdate方法：
固定更新方法。
所有和物理相关的操作都要写在FixedUpdate中。
固定更新方法一次0.02秒，一秒50次。
Edit -> Project Settings -> Time 可以修改Fixed Timestep修改时间间隔。

Update()方法是每帧执行一次。
画面每渲染完一次就是一帧，每帧的时间不固定（和场景有关系）。

在Update（）方法中执行物理操作，会出现卡顿。






7.21：
两物体碰撞产生的效果只是物理上的，即RigidBody造成的

刚体碰撞事件监测与处理:
OnCollisionEnter(Collision):当碰撞开始时调用，只会调用一次。
OnCollisionExit(Collision):当碰撞结束时调用，只会调用一次。
OnCollisionStay(Collision):当碰撞进行中，持续调用。
Collision参数：
为一个Collision类，传递碰撞信息。
Collision.gameObject属性，与当前物体碰撞的物体引用。（即获得被撞物体的引用）
gameObject.name属性，当前被撞物体的名字。

以上Collision函数与Start / Update级别一致。


刚体触发事件监测与处理：
触发器：
将碰撞体属性面板上的Is Trigger选项选中，当前物体的碰撞体就变成了触发器。

移动的刚体物体会穿透 勾选Is Trigger的物体。

触发事件：
当一个用刚体控制的物体进入另一个物体的触发器范围内，就是触发事件。

触发用途：不与目标物体发生直接的碰撞，而是只要进入触发范围内就能执行某些特定操作。

更改触发器范围：修改Collider中Size属性。

触发事件监测方法：
OnTriggerEnter(Collider)
OnTriggerExit(Collider)
OnTriggerStay(Collider)
传递参数是进入的触发器的Collider。

Collider参数：
Collider.gameObject:进入触发物体的引用。
gameObject.name：触发器名字。



网格组件 网格过滤器和渲染器：
网格过滤器Mesh Filter：
只有一个属性Mesh，用来设置当前物体使用哪个模型进行展示。
Mesh网格，即模型。


网格渲染器Mesh Renderer：
用于 渲染 显示 模型。若没有该组件，模型不会显示。
属性:Cast Shadows投射阴影。
     Receive Shadows接受阴影。（可以不接受其他物体到自身上的投影）
     Materials 用于设置哪个材质球渲染当前的模型（Mesh），即之前使用的材质球（实际上就是拖到这个属性）。


案例：
1. 模型旋转实现开门效果。
模型中心点，即模型上坐标轴的中心点。

模型中心点无法改变，所以用如下方法：
创建一个空物体，创建父子关系，通过父物体控制子物体，间接改变模型中心点。

因为开关门旋转轴的中心在门边上，所以需要改中心。（将门放入一个父物体）

中心点工具：
Center：当选中两个模型时，设置为Center，模型组的中心点就在两个模型的中间中心位置。
Pivot：当选中两个模型时，设置为Center，模型组的中心点就在后选中的模型的中间中心位置。
这样选中父物体再切换为Pivot可以使用父物体的中心。

使用键盘按键实现开关门：
Transform.Rotate(Vector3,float):
Vector3：沿某个轴
float：角度

Vector3.up 向上，即y轴


2. 触发器实现开关门。
创建空物体，添加Box Collider，设置大小和中心点来包裹住源物体
勾选Is Trigger

查找游戏物体：
此处是GameObject，用的是类的静态方法。
GameObject.Find(String):静态方法，通过名字查找。
String是物体名字。

上面find方法返回一个gameobject，直接调用GetComponent<脚本名>()
返回值赋值给一个 脚本名类型的变量。




1. 通过Tag标签查找物体。
Tag标签。
设置：Inspector顶部有一个Tag选项。如果是untagged，下拉点击Add tag。
tags下拉框 点击加号。

通过标签查找N个物体：
GameObject.FindGameObjectsWithTag(string)：静态方法
返回一个数组。
String 标签名



2. 触发器实现桌椅跳动。
首先创建触发器，创建空物体，添加Box Collider，勾选Is Trigger。
实现enter 和 exit方法。



















