7.23：

在使用Unity开发MMORPG,MMOARPG（大型页游）客户端时，50%以上工作量是在写UI界面和UI界面的逻辑。

插件
1. NGUI：
使用最多的第三方UI插件。

2. UGUI:
Unity 自带的。

3. OnGui:
用于扩展Unity引擎界面。

4. Legacy GUi：
只能实现稍实用但是不好看的UI。

GUI Text组件：主要用于文字显示。
创建方法：
新建一个空物体，添加Rendering -> GUI Text组件即可。
文字大小默认为0，单位是像素（为 0 会看不到）。

Pixel offset像素偏移量：设置x / y值设置文本在场景中显示的位置。

注意 ！！
主摄像机没有GUI layer控件会无法显示文本。


GUItexture：用于图片的显示。
首先创建空物体，然后同样在Rendering中选择组件搭载。
使用：
首先将Transform中Scale改为0.1，之后再设置相关属性。

Texture属性:设置要显示的图片。
Color属性：设置图片颜色，默认状态下不影响图片显示效果，只影响色调。（灰色不会影响，默认为灰色）

Pixel Inset像素设置：
X / Y 设置图片显示位置。
W / H 设置图片宽高。


鼠标事件：
之前所用的 Input类下的鼠标输入是全局的，只能获取鼠标的按键状态。

此处的是挂载在一个物体上，只当操作该物体时才生效。

常用事件方法：
OnMouseEnter():
OnMouseExit():
OnMouseDown():鼠标按下，即单击。

颜色参数：Color结构体，Color.red,...



特效组件 
TrailRenderer拖尾渲染器:用于渲染显示“拖尾特效”

特效应用：用于高速运动物体，炮弹、子弹等。

！！体现物体运动速度。

创建：新建一个空物体，添加TraiRenderer组件 Effects -> Trail Renderer

在Scene移动该空物体就可以看到效果。

TrailRenderer -> Materials 材质球使用：使用材质渲染拖尾。
注意Element属性

若没有赋值材质球，默认是粉红色的。


制作透明材质球：
创建，设置Shader为Particles -> Additive
最后赋予Texture。

常用属性：Time：拖尾持续时间。
Start Width：开始宽度。
End Width：结束宽度。
Color：
实际开发中，美工给的图往往是黑白图，黑色是透明区，白色不透明。
可以通过手动改Color，让白色区域显示特定颜色。


LineRenderer：
线渲染器，渲染显示线特效。
应用：激光效果，子弹瞄准。

常用属性：
Positions：开始，结束位置。Size为2说明是2个结点。





7.24：
声音组件AudioSource：
用于播放AudioClip资源。

使用时同样创建一个空物体（可选），添加AudioSource组件。
属性：
Audio Clip： 资源
PlayOnAwake：唤醒时播放，游戏一运行就播放。
Loop：
Mute：静音。
Volume：0~1
Spatial Blend：空间混合。为0是2D，任何位置听的都一样。为1是3D，根据摄像机与音频源距离有关。
做2D 或是 3D游戏时要注意。

Audio Listener：声音侦听器。默认挂载在摄像机上，作为“耳朵”。

Audio Source常用函数：
Play / Stop / Pause
Stop和Pause区别在于点击以后重新再play，stop是从头开始播放，Pause是接着刚刚的地方播放。


实例化游戏物体：
GameObject.Instantiate(Object,Vector3,Quaternion)
参数分别为：预制体，目标生成位置，旋转状态（四元数）。
Quaternion.identity：无旋转。

脚本内变量定义为Public即可引用外部物体。（拖拽即可）

构造随机位置：
Random.Range(min,max)：生成随机数。


销毁游戏物体：
GameObject.Destroy(Object,float) 定时销毁某物体。
float参数：时间。


Invoke函数：归属于MonoBehaviour类

Invoke(string,float)：多少秒后执行某个函数。
string:要执行的函数名
float:时间

InvokeRepeating(string,float,float):多少秒（第二个）后执行，每隔多少秒（第三个）后再执行

CancelInvoke():取消 所有 Invoke调用。


消息发送：
gameObject.SendMessage(String)：通知 该游戏体上 脚本文件中指定方法执行
String是方法名，要执行的方法的名称。

注意，private方法无法执行！！

或者可以通过ganmeObject.GetComponent<脚本名>.函数名来实现




7.25：
协同程序Coroutine：
在脚本运行过程中，需要执行一些其他的代码，遇到条件会挂起。
类似于开线程，但不是。
区别在于：任何时刻只有一个系统程序运行，与多线程程序不一样（多个线程同时）。

使用前提：必须继承MonoBehaviour
e.g.:
IEnumerator Task()
{yield return new WaitForSeconds(2);
Debug.Log();
}

IEnumerator:返回值类型，协同程序固定写法
yield return:返回

调用协同程序：
StartCoroutine("协同程序方法名")(e.g.:"Task3")

停止：
Stop Coroutine("协同程序方法名")(e.g.:"Task3")

同一个协同程序可以 yield return 多个值。




7.26：
生命周期
脚本生命周期即挂载的物体生命周期
生命周期事件 是一些特定的方法
全部定义在MonoBehaviour 类中

生命周期图片！！重要！！

Editor -> Initialization -> Physices -> Input -> Game Logic (Update / yield) -> Rendering -> End of game
-> Pausing -> Disable -> Decomposing

Instantiate出来的是 Object 类型

父类无法赋值给子类  多态！！

所以实例化出来的类型 需要 as GameObject 才能赋值给 GameObject


按照使用顺序:
1.Awake():唤醒事件，只执行一次。
2.OnEnable():启用事件，只执行一次，当脚本组件被启用时执行一次，即勾选脚本组件前的方框。
3.Start()
前三个常用于初始化。

4.FixedUpdate():固定更新，0.02秒一次。所有物理组件相关更新都在此调用。
5.Update()
6.LateUpdate():稍后更新，在Update之后执行。
7.OnGUI():渲染事件
8.OnDisable():禁用事件，执行一次，在OnDestroy之前执行，当脚本组件被启用时执行一次，即勾选脚本组件前的方框。
9.OnDestroy():销毁事件，执行一次。





7.27：
常用API
工具类：
1. Screen 屏幕类：
Screen.width:静态只读，屏幕宽度。
Screen.height:静态只读，屏幕高度。

在Unity开发下，这两个值取的是Game窗口的宽度和高度（缩放窗口 值就改变）
编译打包后运行，是具体设备的宽度和高度。

2.Time时间类：
Time.time:静态只读，从游戏开始到现在经过的时间（秒数）。

Time.deltaTime:静态只读，时间增量。渲染完上一帧画面消耗的时间。
（可用于实现倒计时）

Time.timeScale:静态可读写。时间缩放程度，可用于暂停游戏。
当值为1时，游戏正常。为0时，游戏暂停。为0.5时，游戏处于慢放0.5倍状态。



3.Mathf数学类：
Mathf是一个结构体类型，包含各种数学运算函数。
Mathf.Abs()
Mathf.Round():四舍五入 Mathf.Round(0.6f) -> 1

插值运算函数：
Mathf.Lerp(float a,float b,float f)
基于f，返回a到b之间的插值，f限制在0-1之间。
就是按比例返回，例如a=2.0,b=5.0,f=0.3,返回2.9 (2+(5-2)*0.3)

一个数从0插值到10
num = Mathf.Lerp(num,10,Time.deltaTime)

插值运算的目的基本都是为了  ”平滑过渡“


物理射线后期使用频率极高！！


物理射线之原理分析：
物理射线可以与游戏中其他物体的Collider碰撞，碰撞即结束。

通过摄像机创建射线。

Camera.main: 代表tag设置为Main Camera的摄像机的 Camera组件的引用。
（解释：camera名称为Main camera，其下的组件有一个叫Camera）

摄像机组件(对象)下的一个方法：
m_Camera.ScreenPointToRay(Vector3)
屏幕点转化为射线，该方法返回一个Ray类型的射线。

点通常写鼠标的点击位置，这样就代表从摄像机向点的位置发出一个射线。

Input.mousePosition:鼠标所在的位置值。

Ray 射线，一个结构体。


检查射线与其他物体的碰撞：
RaycastHit 结构体，用于存储射线的碰撞信息。

Physics.Raycast(Ray,out RaycastHit)静态方法，射线检查。
该方法返回值为bool类型
如果与场景中物理组件相碰撞，返回值为真，并将信息存储在RaycastHit类型的变量中。

out关键字与ref关键字类似，都是引用中从方法内接收值。
区别在于ref关键字必须初始化，out形参不需要。


tip:方法前加注释，三条斜杠

总结，三个步骤：
1. 摄像机建立射线
2. 检查射线碰撞，得到碰撞信息
3. 根据信息处理



7.28：
射线打砖块案例：

射线碰撞检测发射子弹：
RaycastHit.point:获取射线碰撞点。

Vector3向量计算方向：
方向是矢量，也是Vector3类型的，由末位置减去初位置得到。


此处有问题：砖块生成后会弹射开来，无法形成墙壁。？？？


7.29：
优化：
1.自动销毁砖块
当低于地面时销毁。

2.自动销毁子弹：使用时间判断（3s内自动销毁）。

3.砖块颜色五彩：
获取d到渲染组件，随机生成。（R G B 的值随机生成，取值范围 0—1）

Debug绘制射线：
Debug.DrawRay(Vector3,Vector3,Color)
第一个参数：起点位置
第二个参数：终点减去起点位置的一个方向

运行以后只能在Scene中看到（调试）。



飞盘射击Demo：
UnityPackage打包格式，存储项目资源
导入：
直接拖入project里，或者Assets -> import -> custom

制作场景时确保方向正确，z是前方朝前，y是上方朝上。





7.30：
鼠标控制手臂朝向：
使用射线控制：
主摄像机发射射线，与场景物体碰撞，获取一个碰撞点，然后手臂朝向该碰撞点。

Transform.LookAt(Vector3):朝向世界中的一个点。
如果选hit.point就是转向射线碰撞信息中的点

前提是有碰撞器！！否则检测不到碰撞物体


背景模型添加碰撞器组件
添加Mesh Collider组件，使用简模进行碰撞检测。
简模作用：降低物理运算资源消耗，提高游戏性能。（顶点少很多）

Mesh网格由顶点组成

控制旋转轴：新建父物体，控制父物体


针对有有父子关系的两个物体的查找：（GameObject.find会把重名物体都查出来）

m_Transform.FindChild(string):在当前物体子物体查找游戏物体。//该方法已经废弃，使用find即可，返回值为transform类型


枪口添加激光特效：
枪口位置添加LineRenderer
注意此处添加空物体移动的是 pivot，即真实坐标，不是Global

通过子物体的transform组件来反查其所在物体（find 函数），然后查找相应组件

SetPosition(int,Vector3):设置线的起始结束位置。
第一个参数选择是起始还是结束，第二个选择位置。
修改的即是Position中的Element0和Element1





7.31：
飞盘预制体制作：
hit.collider.tag可以获取碰撞物体的标签

Transform.parent:属返回当前物体的父物体的Transform 值
Transform.GetComponentsInChildren<T>():获取所有子物体的某个组件

gameObject.AddComponent<T>():动态添加组件

Transform.SetParent(Transform):将当前物体设置为另一个物体的子物体
用途：让自动生成的物体作为父物体的子物体

添加声音：
给摄像机添加AudioSource组件

添加背景音效：
给角色模型添加声音源，默认不播放，射击一次播放一次





8.4:
UI界面搭建：
新建3个UI空物体，分别在其下创建子物体用来实现UI。

建立UIText：
create -> UI -> Text,在自动生成的Canvas物体下创建

字体过大无法显示：
添加组件：Layout -> Content Size Fitter,都选为Preferred Size。

有关Rect Transform知识见浏览器收藏 简书大佬


游戏管理器：
首先创建一个总的脚本来控制整个流程。

游戏管理器框架编写：
1.创建当前游戏窗台枚举。当前游戏只有三种:开始，进行，结束
public enum GameState
{
    START,
    GAME,
    END
}
2.查找获取三组UI的引用，控制显示次序。
通过GameObject.Find 查找持有
可以使用gameObject.setActive()隐藏UI

3.定义一个字段存取当前游戏状态。
4.定义一个切换游戏状态的方法。
重点：


5.通过背景声音和UI演示状态切换的效果。



游戏界面逻辑：
1.开始界面：
设置手臂不能移动，飞盘不能生成。

脚本实质上就是一个类！！！所以可以直接用脚本类的名创建一个引用！！！
但是由于可能会有重名，所以需要查找到具体物体身上的脚本。
！！！
e.g.:weapon wp = GameObject.Find("Weapon").GetComponent<Weapon>();
！！！
其次，由于Invoke函数的存在，停止当前函数并不能停止Invoke函数，需要调用相应的CancelInvoke函数才行。
！！！
！！！

—— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— ——

小发现：
如果有错误，Unity会执行到Bug之前，所有都能执行（场景加载，声音添加等）
然而若有错，接下来的代码都不执行。

无法对脚本组件进行setActive() 方法

Text等 UI 组件在 UnityEngine.UI 类下，需要先 using

使用 find 函数不论父子物体均可以直接使用

—— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— —— ——


如何调用类里的枚举类：
前提是public
e.g.: GameObject.GameState即可


如何使用button组件来添加脚本控制：
首先将写好的脚本挂载到某一物体上。
勾选在onClick下的 + 号，首先选择挂载的物体，然后再选择使用的脚本，再选择调用的函数。


分数累加：
在Game Manager中定义分数，并写增加分数的公开方法（方便weapon脚本调用，同时便于修改UI中的分数）

控制UI显示分数：
首先获取Text组件
在修改分数的同时修改text内容即可


倒计时修改：
1.新建字段存储时间。
2.定义一个标志位，用于开始和停止倒计时。
3.定义一个方法，修改标志位。
4.在Update中实现倒计时。
5.控制UI显示倒计时。


结束界面逻辑：
显示总分数：
查找到分数UI再显示即可。


重新开始按钮：
与开始游戏按钮类似。
编写时出现错误，可用 Debug.Log 方法输出尝试。

原因在 Update 函数中 在倒计时小于0时会跳转到 结束界面。 此处不是 Bug 。
因此倒计时要置位。


gameObject.GetComponentsInChildren<Transform>() (根据父物体的 Transform 查找到所有子物体的 transform, 再反推到所有子物体的gameObject)
该函数会把父物体也查找到里面，且父物体为数组序列下标第一个。
所以要Destroy，需要从第二个，即下标为 1 的项开始Destroy。








